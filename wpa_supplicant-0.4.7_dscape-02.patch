From: Sven Henkel <shenkel@gmail.com>

(Comment by Jiri Benc <jbenc@suse.cz>: This is a patch that adds a "dscape"
driver to wpa_supplicant 0.4.7. It's purpose is to allow testing of WPA with
Devicescape ieee80211 stack. There is a plan to update Wireless Extension
support in the stack so the "wext" driver can be used and this patch won't
be needed.)

diff -upN wpa_supplicant-0.4.7/wpa_supplicant/defconfig wpa_supplicant-0.4.7-dev/wpa_supplicant/defconfig
--- wpa_supplicant-0.4.7/wpa_supplicant/defconfig	2005-09-24 20:30:43.000000000 +0200
+++ wpa_supplicant-0.4.7-dev/wpa_suplicant/defconfig	2005-12-18 12:13:21.000000000 +0100
@@ -38,6 +38,9 @@
 # Driver interface for Host AP driver
 CONFIG_DRIVER_HOSTAP=y
 
+# Driver interface for Devicescape stack
+CONFIG_DRIVER_DSCAPE=y
+
 # Driver interface for Agere driver
 #CONFIG_DRIVER_HERMES=y
 # Change include directories to match with the local setup
diff -upN wpa_supplicant-0.4.7/src/drivers/driver_dscape.c wpa_supplicant-0.4.7-dev/src/drivers/driver_dscape.c
--- wpa_supplicant-0.4.7/src/drivers/driver_dscape.c	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/src/drivers/driver_dscape.c	2005-12-18 12:48:32.000000000 +0100
@@ -0,0 +1,466 @@
+/*
+ * WPA Supplicant - driver interaction with Devicescape stack
+ * Copyright (c) 2003-2005, Sven Henkel <shenkel@gmail.com>
+ *
+ * This file includes code from the hostap-driver for WPA supplicant
+ * Copyright (c) 2003-2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#include "includes.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+
+#include "wireless_copy.h"
+#include "common.h"
+#include "driver.h"
+#include "driver_wext.h"
+#include "eloop.h"
+#include "driver_dscape.h"
+
+
+
+
+struct wpa_driver_dscape_data {
+        void *wext; /* private data for driver_wext */
+        void *ctx;
+        char ifname[IFNAMSIZ + 1];
+        int sock;
+        int current_mode; /* infra/adhoc */
+};
+
+
+static int dscape_ioctl(struct wpa_driver_dscape_data *drv,
+			 struct prism2_hostapd_param *param,
+			 int len, int show_err)
+{
+	struct iwreq iwr;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) param;
+	iwr.u.data.length = len;
+
+	if (ioctl(drv->sock, PRISM2_IOCTL_HOSTAPD, &iwr) < 0) {
+		int ret = errno;
+		if (show_err) 
+			perror("ioctl[PRISM2_IOCTL_HOSTAPD]");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int prism2param(struct wpa_driver_dscape_data *drv, int param,
+		       int value)
+{
+	struct iwreq iwr;
+	int *i, ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	i = (int *) iwr.u.name;
+	*i++ = param;
+	*i++ = value;
+
+	if (ioctl(drv->sock, PRISM2_IOCTL_PRISM2_PARAM, &iwr) < 0) {
+		fprintf(stderr, "ioctl[PRISM2_IOCTL_PRISM2_PARAM] param = %d  value = %d\n", param, value);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int wpa_driver_dscape_set_wpa_ie(struct wpa_driver_dscape_data *drv, const u8 *wpa_ie, size_t wpa_ie_len)
+{
+	struct prism2_hostapd_param *param;
+	int res;
+	size_t blen = PRISM2_DSCAPE_GENERIC_ELEMENT_HDR_LEN + wpa_ie_len;
+
+	if (blen < sizeof(*param))
+		blen = sizeof(*param);
+
+	param = (struct prism2_hostapd_param *) malloc(blen);
+	if (param == NULL)
+		return -1;
+
+	memset(param, 0, blen);
+	param->cmd = PRISM2_HOSTAPD_SET_GENERIC_INFO_ELEM;
+	param->u.set_generic_info_elem.len = wpa_ie_len;
+	memcpy(param->u.set_generic_info_elem.data, wpa_ie, wpa_ie_len);
+	res = dscape_ioctl(drv, param, blen, 1);
+
+	free(param);
+
+	return res;
+}
+
+static int wpa_driver_dscape_set_wpa(void *priv, int enabled)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	int ret = 0;
+
+	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
+
+	if (!enabled && wpa_driver_dscape_set_wpa_ie(drv, NULL, 0) < 0)
+		ret = -1;
+
+	//if (prism2param(drv, PRISM2_PARAM_HOST_ROAMING, enabled ? 2 : 0) < 0)
+		//ret = -1;
+	//if (prism2param(drv, PRISM2_PARAM_WPA, enabled) < 0)
+		//ret = -1;
+
+	return ret;
+}
+
+
+
+static int wpa_driver_dscape_set_key(void *priv, wpa_alg alg, const u8 *addr, int key_idx,
+					int set_tx, const u8 *seq, size_t seq_len,
+					const u8 *key, size_t key_len)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	struct prism2_hostapd_param *param;
+
+	u8 *buf;
+	size_t blen;
+	int ret = 0;
+	char *alg_name;
+	//int i;
+
+	switch (alg) {
+	case WPA_ALG_NONE:
+		alg_name = "none";
+		break;
+	case WPA_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case WPA_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case WPA_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "%s: alg=%s key_idx=%d set_tx=%d seq_len=%lu "
+		   "key_len=%lu", __FUNCTION__, alg_name, key_idx, set_tx,
+		   (unsigned long) seq_len, (unsigned long) key_len);
+
+// 	printf("key = ");
+// 	for (i = 0; i < key_len; i++) {
+// 		printf("%.2x ", key[i]);
+// 	}
+// 	printf("\n");
+
+	if (seq_len > 8)
+		return -2;
+
+	blen = sizeof(*param) + key_len;
+	buf = malloc(blen);
+	if (buf == NULL)
+		return -1;
+	memset(buf, 0, blen);
+
+	param = (struct prism2_hostapd_param *) buf;
+	param->cmd = PRISM2_SET_ENCRYPTION;
+	/* TODO: In theory, STA in client mode can use five keys; four default
+	 * keys for receiving (with keyidx 0..3) and one individual key for
+	 * both transmitting and receiving (keyidx 0) _unicast_ packets. Now,
+	 * keyidx 0 is reserved for this unicast use and default keys can only
+	 * use keyidx 1..3 (i.e., default key with keyidx 0 is not supported).
+	 * This should be fine for more or less all cases, but for completeness
+	 * sake, the driver could be enhanced to support the missing key. */
+#if 0 
+	if (addr == NULL)
+		memset(param->sta_addr, 0xff, ETH_ALEN);
+	else
+		memcpy(param->sta_addr, addr, ETH_ALEN);
+#else
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+#endif
+	strncpy((char *) param->u.crypt.alg, alg_name,
+		HOSTAP_CRYPT_ALG_NAME_LEN);
+	param->u.crypt.flags = set_tx ? HOSTAP_CRYPT_FLAG_SET_TX_KEY : 0;
+	param->u.crypt.idx = key_idx;
+	//memcpy(param->u.crypt.seq, seq, seq_len);
+	param->u.crypt.key_len = key_len;
+	memcpy(param->u.crypt.key, key, key_len);
+
+	if (dscape_ioctl(drv, param, blen, 1)) {
+		wpa_printf(MSG_WARNING, "Failed to set encryption.");
+		//show_set_key_error(param);
+		ret = -1;
+	}
+	free(buf);
+
+	return ret;
+}
+
+static int wpa_driver_dscape_set_countermeasures(void *priv, int enabled)
+{
+	//FIXME: we should tell the driver to drop all tkip packets iff enabled
+	fprintf(stderr, "FIXME wpa_driver_dscape_set_countermeasures entered\n");
+	return 0;
+}
+
+static int wpa_driver_dscape_set_drop_unencrypted(void *priv, int enabled)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	int ret = prism2param(drv, PRISM2_PARAM_DROP_UNENCRYPTED, enabled);
+	if (ret < 0)
+		return ret;
+
+	// allow eapol packets
+	ret = prism2param(drv, PRISM2_PARAM_EAPOL, enabled);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wpa_driver_dscape_mlme(struct wpa_driver_dscape_data *drv, const u8 *addr, int cmd, int reason_code)
+{
+        struct prism2_hostapd_param param;
+        int ret;
+
+        /* There does not seem to be a better way of deauthenticating or
+         * disassociating with Prism2/2.5/3 than sending the management frame
+         * and then resetting the Port0 to make sure both the AP and the STA
+         * end up in disconnected state. */
+        memset(&param, 0, sizeof(param));
+        param.cmd = PRISM2_HOSTAPD_MLME;
+        memcpy(param.sta_addr, addr, ETH_ALEN);
+        param.u.mlme.cmd = cmd;
+        param.u.mlme.reason_code = reason_code;
+        ret = dscape_ioctl(drv, &param, sizeof(param), 1);
+
+//        if (ret == 0) {
+//                usleep(100000);
+//                ret = wpa_driver_hostap_reset(drv, 2);
+//        }
+        return ret;
+}
+
+static int wpa_driver_hostap_associate(void *priv, struct wpa_driver_associate_params *params)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	int ret = 0;
+	int ieee8021x = 0;
+	int key_mgmt = IEEE80211_KEY_MGMT_NONE;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+
+// 	if (params->mode != drv->current_mode) {
+// 		/* At the moment, Host AP driver requires host_roaming=2 for
+// 		 * infrastructure mode and host_roaming=0 for adhoc. */
+// 		if (prism2param(drv, PRISM2_PARAM_HOST_ROAMING,
+// 				params->mode == IEEE80211_MODE_IBSS ? 0 : 2) <
+// 		    0) {
+// 			wpa_printf(MSG_DEBUG, "%s: failed to set host_roaming",
+// 				   __func__);
+// 		}
+// 		drv->current_mode = params->mode;
+// 	}
+
+	if (prism2param(drv, PRISM2_PARAM_PRIVACY_INVOKED,
+			params->key_mgmt_suite != KEY_MGMT_NONE) < 0)
+		ret = -1;
+	if (wpa_driver_dscape_set_wpa_ie(drv, params->wpa_ie,
+					 params->wpa_ie_len) < 0)
+		ret = -1;
+
+	switch(params->key_mgmt_suite) {
+		case KEY_MGMT_802_1X:
+			ieee8021x = 1;
+			key_mgmt = IEEE80211_KEY_MGMT_IEEE8021X;
+			break;
+		case KEY_MGMT_PSK:
+			key_mgmt = IEEE80211_KEY_MGMT_WPA_PSK;
+			break;
+		case KEY_MGMT_NONE:
+			key_mgmt = IEEE80211_KEY_MGMT_NONE;
+			break;
+		case KEY_MGMT_802_1X_NO_WPA:
+		case KEY_MGMT_WPA_NONE:
+			key_mgmt = IEEE80211_KEY_MGMT_NONE; //FIXME Do those modes have a corresponding mode in dscape?
+			break;
+	}
+
+	if (prism2param(drv, PRISM2_PARAM_IEEE_802_1X, ieee8021x) < 0) {
+		wpa_printf(MSG_DEBUG, "hostap: Failed to configure "
+			   "ieee_802_1x param");
+		ret = -1;
+	}
+
+	if (prism2param(drv, PRISM2_PARAM_KEY_MGMT, key_mgmt) < 0) {
+		wpa_printf(MSG_DEBUG, "hostap: Failed to configure "
+			   "key-management param");
+		ret = -1;
+	}
+
+	if (wpa_driver_wext_set_mode(drv->wext, params->mode) < 0)
+		ret = -1;
+	if (params->freq &&
+	    wpa_driver_wext_set_freq(drv->wext, params->freq) < 0)
+		ret = -1;
+	if (wpa_driver_wext_set_ssid(drv->wext, params->ssid, params->ssid_len)
+	    < 0)
+		ret = -1;
+	if (wpa_driver_wext_set_bssid(drv->wext, params->bssid) < 0)
+		ret = -1;
+
+	return ret;
+}
+
+
+static int wpa_driver_dscape_deauthenticate(void *priv, const u8 *addr, int reason_code)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+        wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        return wpa_driver_dscape_mlme(drv, addr, MLME_STA_DEAUTH, reason_code);
+}
+
+static int wpa_driver_dscape_disassociate(void *priv, const u8 *addr, int reason_code)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+        wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        return wpa_driver_dscape_mlme(drv, addr, MLME_STA_DISASSOC, reason_code);
+}
+
+static int wpa_driver_dscape_scan(void *priv, const u8 *ssid, size_t ssid_len)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	struct prism2_hostapd_param param;
+	int ret;
+
+	fprintf(stderr, "wpa_driver_dscape_scan entered\n");
+
+	if (ssid == NULL) {
+		/* Use standard Linux Wireless Extensions ioctl if possible
+		 * because some drivers using hostap code in wpa_supplicant
+		 * might not support Host AP specific scan request (with SSID
+		 * info). */
+		return wpa_driver_wext_scan(drv->wext, ssid, ssid_len);
+	}
+
+	if (ssid_len > 32)
+		ssid_len = 32;
+
+	memset(&param, 0, sizeof(param));
+	param.cmd = PRISM2_HOSTAPD_SCAN_REQ;
+	param.u.scan_req.ssid_len = ssid_len;
+	memcpy(param.u.scan_req.ssid, ssid, ssid_len);
+	ret = dscape_ioctl(drv, &param, sizeof(param), 1);
+
+	/* Not all drivers generate "scan completed" wireless event, so try to
+	 * read results after a timeout. */
+	eloop_register_timeout(3, 0, wpa_driver_wext_scan_timeout, drv->wext,
+			       drv->ctx);
+
+	return ret;
+}
+
+static int wpa_driver_dscape_set_auth_alg(void *priv, int auth_alg)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	int algs = 0;
+
+	if (auth_alg & AUTH_ALG_OPEN_SYSTEM)
+		algs |= 1;
+	if (auth_alg & AUTH_ALG_SHARED_KEY)
+		algs |= 2;
+	if (auth_alg & AUTH_ALG_LEAP)
+		algs |= 4;
+	if (algs == 0)
+		algs = 1; /* at least one algorithm should be set */
+
+	return prism2param(drv, PRISM2_PARAM_AP_AUTH_ALGS, algs);
+	return 0;
+}
+
+static int wpa_driver_dscape_get_bssid(void *priv, u8 *bssid)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	return wpa_driver_wext_get_bssid(drv->wext, bssid);
+}
+
+static int wpa_driver_dscape_get_ssid(void *priv, u8 *ssid)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	return wpa_driver_wext_get_ssid(drv->wext, ssid);
+}
+
+static int wpa_driver_dscape_get_scan_results(void *priv, struct wpa_scan_result *results, size_t max_size)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+	return wpa_driver_wext_get_scan_results(drv->wext);
+}
+
+static void * wpa_driver_dscape_init(void *ctx, const char *ifname)
+{
+	struct wpa_driver_dscape_data *drv;
+
+	drv = malloc(sizeof(*drv));
+	if (drv == NULL)
+		return NULL;
+	memset(drv, 0, sizeof(*drv));
+
+	drv->wext = wpa_driver_wext_init(ctx, ifname);
+	if (drv->wext == NULL) {
+                free(drv);
+                return NULL;
+        }
+
+        drv->ctx = ctx;
+        strncpy(drv->ifname, ifname, sizeof(drv->ifname));
+        drv->sock = socket(PF_INET, SOCK_DGRAM, 0);
+        if (drv->sock < 0) {
+                perror("socket");
+                wpa_driver_wext_deinit(drv->wext);
+                free(drv);
+                return NULL;
+        }
+
+	return drv;
+}
+
+static void wpa_driver_dscape_deinit(void *priv)
+{
+	struct wpa_driver_dscape_data *drv = priv;
+        wpa_driver_wext_deinit(drv->wext);
+        close(drv->sock);
+        free(drv);
+}
+
+const struct wpa_driver_ops wpa_driver_dscape_ops = {
+        .name = "dscape",
+        .desc = "Devicescape driver",
+        .get_bssid = wpa_driver_dscape_get_bssid,
+        .get_ssid = wpa_driver_dscape_get_ssid,
+        .set_wpa = wpa_driver_dscape_set_wpa,
+        .set_key = wpa_driver_dscape_set_key,
+        .set_countermeasures = wpa_driver_dscape_set_countermeasures,
+        .set_drop_unencrypted = wpa_driver_dscape_set_drop_unencrypted,
+        .scan = wpa_driver_dscape_scan,
+        .get_scan_results = wpa_driver_dscape_get_scan_results,
+        .deauthenticate = wpa_driver_dscape_deauthenticate,
+        .disassociate = wpa_driver_dscape_disassociate,
+        .associate = wpa_driver_hostap_associate,
+        .set_auth_alg = wpa_driver_dscape_set_auth_alg,
+        .init = wpa_driver_dscape_init,
+        .deinit = wpa_driver_dscape_deinit,
+};
diff -upN wpa_supplicant-0.4.7/src/drivers/driver_dscape.h wpa_supplicant-0.4.7-dev/src/drivers/driver_dscape.h
--- wpa_supplicant-0.4.7/src/drivers/driver_dscape.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/src/drivers/driver_dscape.h	2005-12-18 12:41:32.000000000 +0100
@@ -0,0 +1,452 @@
+/*
+ * WPA Supplicant - driver interaction with devicescape stack
+ * Copyright (c) 2005, Sven Henkel <shenkel@gmail.com>
+ *
+ * Derived from Host AP (software wireless LAN access point) user space
+ * daemon for Host AP kernel driver
+ * Copyright 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * See README and COPYING for more details.
+ */
+
+
+#ifndef DSCAPE_DRIVER_H
+#define DSCAPE_DRIVER_H
+
+#ifndef BIT
+#define BIT(n) (1 << (n))
+#endif
+
+
+#ifndef __KERNEL__
+#include "ieee80211_shared.h"
+#endif /* __KERNEL__ */
+
+#define PRISM2_IOCTL_PRISM2_PARAM (SIOCIWFIRSTPRIV + 0)
+#define PRISM2_IOCTL_GET_PRISM2_PARAM (SIOCIWFIRSTPRIV + 1)
+#define PRISM2_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 3)
+#define PRISM2_IOCTL_TEST_PARAM (SIOCIWFIRSTPRIV + 4)
+
+/* PRISM2_IOCTL_PRISM2_PARAM ioctl() subtypes: */
+enum {
+	PRISM2_PARAM_PTYPE = 1,
+	PRISM2_PARAM_TXRATECTRL = 2,
+	PRISM2_PARAM_BEACON_INT = 3,
+	PRISM2_PARAM_PSEUDO_IBSS = 4,
+	PRISM2_PARAM_ALC = 5,
+	PRISM2_PARAM_TXPOWER = 6,
+	PRISM2_PARAM_DUMP = 7,
+	PRISM2_PARAM_OTHER_AP_POLICY = 8,
+	PRISM2_PARAM_AP_MAX_INACTIVITY = 9,
+	PRISM2_PARAM_AP_BRIDGE_PACKETS = 10,
+	PRISM2_PARAM_DTIM_PERIOD = 11,
+	PRISM2_PARAM_AP_NULLFUNC_ACK = 12,
+	PRISM2_PARAM_MAX_WDS = 13,
+	PRISM2_PARAM_AP_AUTOM_AP_WDS = 14,
+	PRISM2_PARAM_AP_AUTH_ALGS = 15,
+	PRISM2_PARAM_MONITOR_ALLOW_FCSERR = 16,
+	PRISM2_PARAM_HOST_ENCRYPT = 17,
+	PRISM2_PARAM_HOST_DECRYPT = 18,
+	PRISM2_PARAM_BUS_MASTER_THRESHOLD_RX = 19,
+	PRISM2_PARAM_BUS_MASTER_THRESHOLD_TX = 20,
+	PRISM2_PARAM_HOST_ROAMING = 21,
+	PRISM2_PARAM_BCRX_STA_KEY = 22,
+	PRISM2_PARAM_IEEE_802_1X = 23,
+	PRISM2_PARAM_ANTSEL_TX = 24,
+	PRISM2_PARAM_ANTSEL_RX = 25,
+	PRISM2_PARAM_MONITOR_TYPE = 26,
+	PRISM2_PARAM_WDS_TYPE = 27,
+	PRISM2_PARAM_HOSTSCAN = 28,
+	PRISM2_PARAM_AP_SCAN = 29,
+
+	/* Instant802 additions */
+	PRISM2_PARAM_CTS_PROTECT_ERP_FRAMES = 1001,
+	PRISM2_PARAM_DROP_UNENCRYPTED = 1002,
+	PRISM2_PARAM_PREAMBLE = 1003,
+	PRISM2_PARAM_RATE_LIMIT = 1004,
+	PRISM2_PARAM_RATE_LIMIT_BURST = 1005,
+	PRISM2_PARAM_SHORT_SLOT_TIME = 1006,
+	PRISM2_PARAM_TEST_MODE = 1007,
+	PRISM2_PARAM_NEXT_MODE = 1008,
+	PRISM2_PARAM_CLEAR_KEYS = 1009,
+	PRISM2_PARAM_ADM_STATUS = 1010,
+	PRISM2_PARAM_ANTENNA_SEL = 1011,
+	PRISM2_PARAM_CALIB_INT = 1012,
+        PRISM2_PARAM_ANTENNA_MODE = 1013,
+	PRISM2_PARAM_PRIVACY_INVOKED = 1014,
+	PRISM2_PARAM_BROADCAST_SSID = 1015,
+        PRISM2_PARAM_STAT_TIME = 1016,
+	PRISM2_PARAM_STA_ANTENNA_SEL = 1017,
+	PRISM2_PARAM_FORCE_UNICAST_RATE = 1018,
+	PRISM2_PARAM_RATE_CTRL_NUM_UP = 1019,
+	PRISM2_PARAM_RATE_CTRL_NUM_DOWN = 1020,
+	PRISM2_PARAM_MAX_RATECTRL_RATE = 1021,
+	PRISM2_PARAM_TX_POWER_REDUCTION = 1022,
+	PRISM2_PARAM_EAPOL = 1023,
+	PRISM2_PARAM_KEY_TX_RX_THRESHOLD = 1024,
+	PRISM2_PARAM_KEY_INDEX = 1025,
+	PRISM2_PARAM_DEFAULT_WEP_ONLY = 1026,
+	PRISM2_PARAM_WIFI_WME_NOACK_TEST = 1033,
+	PRISM2_PARAM_ALLOW_BROADCAST_ALWAYS = 1034,
+	PRISM2_PARAM_SCAN_FLAGS = 1035,
+	PRISM2_PARAM_HW_MODES = 1036,
+	PRISM2_PARAM_CREATE_IBSS = 1037,
+	PRISM2_PARAM_WMM_ENABLED = 1038,
+	PRISM2_PARAM_MIXED_CELL = 1039,
+	PRISM2_PARAM_KEY_MGMT = 1040,
+	PRISM2_PARAM_RADAR_DETECT = 1043,
+	PRISM2_PARAM_SPECTRUM_MGMT = 1044,
+	/* NOTE: Please try to coordinate with other active development
+	 * branches before allocating new param numbers so that each new param
+	 * will be unique within all branches and the allocated number will not
+	 * need to be changed when merging new features. Existing numbers in
+	 * the mainline (or main devel branch) must not be changed when merging
+	 * in new features. */
+};
+
+/* PRISM2_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	PRISM2_HOSTAPD_FLUSH = 1,
+	PRISM2_HOSTAPD_ADD_STA = 2,
+	PRISM2_HOSTAPD_REMOVE_STA = 3,
+	PRISM2_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	PRISM2_SET_ENCRYPTION = 6,
+	PRISM2_GET_ENCRYPTION = 7,
+	PRISM2_HOSTAPD_SET_FLAGS_STA = 8,
+	PRISM2_HOSTAPD_GET_RID = 9,
+	PRISM2_HOSTAPD_SET_RID = 10,
+	PRISM2_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	PRISM2_HOSTAPD_MLME = 13,
+
+	/* Instant802 additions */
+	PRISM2_HOSTAPD_SET_BEACON = 1001,
+        PRISM2_HOSTAPD_GET_HW_FEATURES = 1002,
+        PRISM2_HOSTAPD_SCAN = 1003,
+	PRISM2_HOSTAPD_WPA_TRIGGER = 1004,
+	PRISM2_HOSTAPD_SET_RATE_SETS = 1005,
+        PRISM2_HOSTAPD_ADD_IF = 1006,
+        PRISM2_HOSTAPD_REMOVE_IF = 1007,
+        PRISM2_HOSTAPD_GET_DOT11COUNTERSTABLE = 1008,
+        PRISM2_HOSTAPD_GET_LOAD_STATS = 1009,
+        PRISM2_HOSTAPD_SET_STA_VLAN = 1010,
+	PRISM2_HOSTAPD_SET_GENERIC_INFO_ELEM = 1011,
+	PRISM2_HOSTAPD_SET_CHANNEL_FLAG = 1012,
+	PRISM2_HOSTAPD_SET_REGULATORY_DOMAIN = 1013,
+	PRISM2_HOSTAPD_SET_TX_QUEUE_PARAMS = 1014,
+	PRISM2_HOSTAPD_SET_BSS = 1015,
+	PRISM2_HOSTAPD_GET_TX_STATS = 1016,
+	PRISM2_HOSTAPD_UPDATE_IF = 1017,
+	PRISM2_HOSTAPD_SCAN_REQ = 1019,
+	PRISM2_STA_GET_STATE = 1020,
+	PRISM2_HOSTAPD_FLUSH_IFS = 1021,
+	PRISM2_HOSTAPD_SET_RADAR_PARAMS = 1023,
+	PRISM2_HOSTAPD_SET_QUIET_PARAMS = 1024,
+	PRISM2_HOSTAPD_GET_TX_POWER = 1025,
+	/* NOTE: Please try to coordinate with other active development
+	 * branches before allocating new param numbers so that each new param
+	 * will be unique within all branches and the allocated number will not
+	 * need to be changed when merging new features. Existing numbers in
+	 * the mainline (or main devel branch) must not be changed when merging
+	 * in new features. */
+};
+
+	/* these definitions mirror the ieee80211_i.h
+	 * IEEE80211_DISABLED, ... IEEE80211_ASSOCIATED enumeration */
+enum {
+	PRISM2_PARAM_STA_DISABLED,
+	PRISM2_PARAM_STA_AUTHENTICATE,
+	PRISM2_PARAM_STA_ASSOCIATE,
+	PRISM2_PARAM_STA_ASSOCIATED,
+};
+
+#define PRISM2_HOSTAPD_MAX_BUF_SIZE 2048
+#define HOSTAP_CRYPT_ALG_NAME_LEN 16
+
+/* Use this to make sure that structure elements are correctly aligned
+ * for access as other types. Most commonly, this affects the placeholder
+ * types used for data at the end of a structure in this union.
+ */
+#ifdef __GNUC__
+#undef	ALIGNED
+#define ALIGNED __attribute__ ((aligned))
+#else
+/* Check if it has been defined elsewhere */
+#ifndef ALIGNED
+#error "Must define ALIGNED to generate aligned structure elements"
+#endif
+#endif
+
+struct prism2_hostapd_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	u8 pad[2];
+	union {
+		struct {
+			u16 aid;
+			u16 capability;
+			u8 supp_rates[32];
+			/* atheros_super_ag and enc_flags are only used with
+			 * IEEE80211_ATHEROS_SUPER_AG 
+			 */
+			u8 atheros_super_ag;
+			u8 atheros_xr_mode;
+			u8 wds_flags;
+#define IEEE80211_STA_DYNAMIC_ENC BIT(0)
+			u8 enc_flags;
+		} add_sta;
+		struct {
+			u32 inactive_msec;
+			u32 rx_packets;
+			u32 tx_packets;
+			u32 rx_bytes;
+			u32 tx_bytes;
+			u32 current_tx_rate; /* in 100 kbps */
+                        u32 channel_use;
+                        u32 flags;
+			u32 num_ps_buf_frames;
+			u32 tx_retry_failed;
+			u32 tx_retry_count;
+			u32 last_rssi;
+			u32 last_ack_rssi;
+		} get_info_sta;
+		struct {
+			u8 alg[HOSTAP_CRYPT_ALG_NAME_LEN];
+			u32 flags;
+			u32 err;
+			u8 idx;
+#define HOSTAP_SEQ_COUNTER_SIZE 8
+			u8 seq_counter[HOSTAP_SEQ_COUNTER_SIZE];
+			u16 key_len;
+			u8 key[0] ALIGNED;
+		} crypt;
+		struct {
+			u32 flags_and;
+			u32 flags_or;
+		} set_flags_sta;
+		struct {
+			u16 rid;
+			u16 len;
+			u8 data[0] ALIGNED;
+		} rid;
+		struct {
+			u16 head_len;
+			u16 tail_len;
+			u8 data[0] ALIGNED; /* head_len + tail_len bytes */
+		} beacon;
+		struct {
+			u16 num_modes;
+			u16 flags;
+			u8 data[0] ALIGNED; /* num_modes * feature data */
+                } hw_features;
+                struct {
+                        u8  now;
+                        s8  our_mode_only;
+                        s16 last_rx;
+                        u16 channel;
+                        s16 interval; /* seconds */
+                        s32 listen;   /* microseconds */
+                } scan;
+		struct {
+#define WPA_TRIGGER_FAIL_TX_MIC BIT(0)
+#define WPA_TRIGGER_FAIL_TX_ICV BIT(1)
+#define WPA_TRIGGER_FAIL_RX_MIC BIT(2)
+#define WPA_TRIGGER_FAIL_RX_ICV BIT(3)
+#define WPA_TRIGGER_TX_REPLAY BIT(4)
+#define WPA_TRIGGER_TX_REPLAY_FRAG BIT(5)
+#define WPA_TRIGGER_TX_SKIP_SEQ BIT(6)
+			u32 trigger;
+		} wpa_trigger;
+		struct {
+			u16 mode; /* MODE_* */
+			u16 num_supported_rates;
+			u16 num_basic_rates;
+			u8 data[0] ALIGNED; /* num_supported_rates * u16 +
+				             * num_basic_rates * u16 */
+                } set_rate_sets;
+                struct {
+			u8 type; /* WDS, VLAN, etc */
+			u8 name[IFNAMSIZ];
+                        u8 data[0] ALIGNED;
+                } if_info;
+                struct dot11_counters {
+                        u32 dot11TransmittedFragmentCount;
+                        u32 dot11MulticastTransmittedFrameCount;
+                        u32 dot11FailedCount;
+                        u32 dot11ReceivedFragmentCount;
+                        u32 dot11MulticastReceivedFrameCount;
+                        u32 dot11FCSErrorCount;
+                        u32 dot11TransmittedFrameCount;
+                        u32 dot11WEPUndecryptableCount;
+			u32 dot11ACKFailureCount;
+			u32 dot11RTSFailureCount;
+			u32 dot11RTSSuccessCount;
+                } dot11CountersTable;
+		struct {
+#define LOAD_STATS_CLEAR BIT(1)
+			u32 flags;
+			u32 channel_use;
+                } get_load_stats;
+                struct {
+                        char vlan_name[IFNAMSIZ];
+			int vlan_id;
+                } set_sta_vlan;
+		struct {
+			u8 len;
+			u8 data[0] ALIGNED;
+		} set_generic_info_elem;
+		struct {
+			u16 mode; /* MODE_* */
+			u16 chan;
+			u32 flag;
+                        u8  power_level; /* regulatory limit in dBm */
+                        u8  antenna_max;
+		} set_channel_flag;
+                struct {
+                        u32 rd;
+                } set_regulatory_domain;
+		struct {
+			u32 queue;
+			s32 aifs;
+			u32 cw_min;
+			u32 cw_max;
+			u32 burst_time; /* maximum burst time in 0.1 ms, i.e.,
+					 * 10 = 1 ms */
+		} tx_queue_params;
+		struct {
+			u32 bss_count;
+			u8 bssid_mask[ETH_ALEN];
+		} set_bss;
+		struct ieee80211_tx_stats {
+			struct {
+				unsigned int len; /* num packets in queue */
+				unsigned int limit; /* queue len (soft) limit
+						     */
+				unsigned int count; /* total num frames sent */
+			} data[4];
+		} get_tx_stats;
+		struct {
+			u8 ssid_len;
+			u8 ssid[0] ALIGNED;
+		} scan_req;
+		struct {
+			u32 state;
+		} sta_get_state;
+		struct {
+#define MLME_STA_DEAUTH 0
+#define MLME_STA_DISASSOC 1
+			u16 cmd;
+			u16 reason_code;
+		} mlme;
+		struct {
+			unsigned int value;
+		/* 	TODO
+			int pulse_width;
+			int num_pulse;
+			int period;
+		*/
+		}radar;
+		struct {
+			unsigned int period;
+			unsigned int offset;
+			unsigned int duration;
+		}quiet;
+		struct {
+			unsigned int tx_power_min;
+			unsigned int tx_power_max;
+		}tx_power;
+		struct {
+			u8 dummy[80]; /* Make sizeof() this struct large enough
+				       * with some compiler versions. */
+		} dummy;
+	} u;
+};
+
+
+#ifndef IEEE80211_TX_QUEUE_NUMS
+#define IEEE80211_TX_QUEUE_NUMS
+/* TODO: these need to be synchronized with ieee80211.h; make a shared header
+ * file that can be included into low-level drivers, 80211.o, and hostapd */
+/* tx_queue_params - queue */
+enum {
+	IEEE80211_TX_QUEUE_DATA0 = 0, /* used for EDCA AC_VO data */
+	IEEE80211_TX_QUEUE_DATA1 = 1, /* used for EDCA AC_VI data */
+	IEEE80211_TX_QUEUE_DATA2 = 2, /* used for EDCA AC_BE data */
+	IEEE80211_TX_QUEUE_DATA3 = 3, /* used for EDCA AC_BK data */
+	IEEE80211_TX_QUEUE_DATA4 = 4,
+	IEEE80211_TX_QUEUE_AFTER_BEACON = 6,
+	IEEE80211_TX_QUEUE_BEACON = 7
+};
+#endif /* IEEE80211_TX_QUEUE_NUMS */
+
+
+#define HOSTAP_CRYPT_FLAG_SET_TX_KEY BIT(0)
+#define HOSTAP_CRYPT_FLAG_PERMANENT BIT(1)
+
+#define HOSTAP_CRYPT_ERR_UNKNOWN_ALG 2
+#define HOSTAP_CRYPT_ERR_UNKNOWN_ADDR 3
+#define HOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED 4
+#define HOSTAP_CRYPT_ERR_KEY_SET_FAILED 5
+#define HOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED 6
+#define HOSTAP_CRYPT_ERR_CARD_CONF_FAILED 7
+
+#define HOSTAP_HW_FLAG_NULLFUNC_OK BIT(0)
+
+enum {
+	IEEE80211_KEY_MGMT_NONE = 0,
+	IEEE80211_KEY_MGMT_IEEE8021X = 1,
+	IEEE80211_KEY_MGMT_WPA_PSK = 2,
+	IEEE80211_KEY_MGMT_WPA_EAP = 3,
+};
+
+
+/* Data structures used for get_hw_features ioctl */
+struct hostapd_ioctl_hw_modes_hdr {
+	int mode;
+	int num_channels;
+	int num_rates;
+};
+
+struct ieee80211_channel_data {
+	short chan; /* channel number (IEEE 802.11) */
+	short freq; /* frequency in MHz */
+	int flag; /* flag for hostapd use (IEEE80211_CHAN_*) */
+};
+
+struct ieee80211_rate_data {
+	int rate; /* rate in 100 kbps */
+	int flags; /* IEEE80211_RATE_ flags */
+};
+
+
+/* ADD_IF, REMOVE_IF, and UPDATE_IF 'type' argument */
+enum {
+	HOSTAP_IF_WDS = 1, HOSTAP_IF_VLAN = 2, HOSTAP_IF_BSS = 3,
+	HOSTAP_IF_STA = 4
+};
+
+struct hostapd_if_wds {
+        u8 remote_addr[ETH_ALEN];
+};
+
+struct hostapd_if_vlan {
+        u8 id;
+};
+
+struct hostapd_if_bss {
+        u8 bssid[ETH_ALEN];
+};
+
+struct hostapd_if_sta {
+};
+
+#define PRISM2_DSCAPE_GENERIC_ELEMENT_HDR_LEN \
+((int) (&((struct prism2_hostapd_param *) 0)->u.set_generic_info_elem.data))
+
+#endif /* DSCAPE_DRIVER_H */
diff -upN wpa_supplicant-0.4.7/driver_dscape_hostapd_ioctl.h wpa_supplicant-0.4.7-dev/driver_dscape_hostapd_ioctl.h
--- wpa_supplicant-0.4.7/driver_dscape_hostapd_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/driver_dscape_hostapd_ioctl.h	2005-12-18 12:13:21.000000000 +0100
@@ -0,0 +1,441 @@
+/*
+ * Host AP (software wireless LAN access point) user space daemon for
+ * Host AP kernel driver
+ * Copyright 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef DSCAPE_HOSTAPD_IOCTL_H
+#define DSCAPE_HOSTAPD_IOCTL_H
+
+#ifndef __KERNEL__
+
+#endif /* __KERNEL__ */
+
+#define PRISM2_IOCTL_PRISM2_PARAM (SIOCIWFIRSTPRIV + 0)
+#define PRISM2_IOCTL_GET_PRISM2_PARAM (SIOCIWFIRSTPRIV + 1)
+#define PRISM2_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 3)
+#define PRISM2_IOCTL_TEST_PARAM (SIOCIWFIRSTPRIV + 4)
+
+/* PRISM2_IOCTL_PRISM2_PARAM ioctl() subtypes: */
+enum {
+	PRISM2_PARAM_PTYPE = 1,
+	PRISM2_PARAM_TXRATECTRL = 2,
+	PRISM2_PARAM_BEACON_INT = 3,
+	PRISM2_PARAM_PSEUDO_IBSS = 4,
+	PRISM2_PARAM_ALC = 5,
+	PRISM2_PARAM_TXPOWER = 6,
+	PRISM2_PARAM_DUMP = 7,
+	PRISM2_PARAM_OTHER_AP_POLICY = 8,
+	PRISM2_PARAM_AP_MAX_INACTIVITY = 9,
+	PRISM2_PARAM_AP_BRIDGE_PACKETS = 10,
+	PRISM2_PARAM_DTIM_PERIOD = 11,
+	PRISM2_PARAM_AP_NULLFUNC_ACK = 12,
+	PRISM2_PARAM_MAX_WDS = 13,
+	PRISM2_PARAM_AP_AUTOM_AP_WDS = 14,
+	PRISM2_PARAM_AP_AUTH_ALGS = 15,
+	PRISM2_PARAM_MONITOR_ALLOW_FCSERR = 16,
+	PRISM2_PARAM_HOST_ENCRYPT = 17,
+	PRISM2_PARAM_HOST_DECRYPT = 18,
+	PRISM2_PARAM_BUS_MASTER_THRESHOLD_RX = 19,
+	PRISM2_PARAM_BUS_MASTER_THRESHOLD_TX = 20,
+	PRISM2_PARAM_HOST_ROAMING = 21,
+	PRISM2_PARAM_BCRX_STA_KEY = 22,
+	PRISM2_PARAM_IEEE_802_1X = 23,
+	PRISM2_PARAM_ANTSEL_TX = 24,
+	PRISM2_PARAM_ANTSEL_RX = 25,
+	PRISM2_PARAM_MONITOR_TYPE = 26,
+	PRISM2_PARAM_WDS_TYPE = 27,
+	PRISM2_PARAM_HOSTSCAN = 28,
+	PRISM2_PARAM_AP_SCAN = 29,
+
+	/* Instant802 additions */
+	PRISM2_PARAM_CTS_PROTECT_ERP_FRAMES = 1001,
+	PRISM2_PARAM_DROP_UNENCRYPTED = 1002,
+	PRISM2_PARAM_PREAMBLE = 1003,
+	PRISM2_PARAM_RATE_LIMIT = 1004,
+	PRISM2_PARAM_RATE_LIMIT_BURST = 1005,
+	PRISM2_PARAM_SHORT_SLOT_TIME = 1006,
+	PRISM2_PARAM_TEST_MODE = 1007,
+	PRISM2_PARAM_NEXT_MODE = 1008,
+	PRISM2_PARAM_CLEAR_KEYS = 1009,
+	PRISM2_PARAM_ADM_STATUS = 1010,
+	PRISM2_PARAM_ANTENNA_SEL = 1011,
+	PRISM2_PARAM_CALIB_INT = 1012,
+        PRISM2_PARAM_ANTENNA_MODE = 1013,
+	PRISM2_PARAM_PRIVACY_INVOKED = 1014,
+	PRISM2_PARAM_BROADCAST_SSID = 1015,
+        PRISM2_PARAM_STAT_TIME = 1016,
+	PRISM2_PARAM_STA_ANTENNA_SEL = 1017,
+	PRISM2_PARAM_FORCE_UNICAST_RATE = 1018,
+	PRISM2_PARAM_RATE_CTRL_NUM_UP = 1019,
+	PRISM2_PARAM_RATE_CTRL_NUM_DOWN = 1020,
+	PRISM2_PARAM_MAX_RATECTRL_RATE = 1021,
+	PRISM2_PARAM_TX_POWER_REDUCTION = 1022,
+	PRISM2_PARAM_EAPOL = 1023,
+	PRISM2_PARAM_KEY_TX_RX_THRESHOLD = 1024,
+	PRISM2_PARAM_KEY_INDEX = 1025,
+	PRISM2_PARAM_DEFAULT_WEP_ONLY = 1026,
+	PRISM2_PARAM_WIFI_WME_NOACK_TEST = 1033,
+	PRISM2_PARAM_ALLOW_BROADCAST_ALWAYS = 1034,
+	PRISM2_PARAM_SCAN_FLAGS = 1035,
+	PRISM2_PARAM_HW_MODES = 1036,
+	PRISM2_PARAM_CREATE_IBSS = 1037,
+	PRISM2_PARAM_WMM_ENABLED = 1038,
+	PRISM2_PARAM_MIXED_CELL = 1039,
+	PRISM2_PARAM_KEY_MGMT = 1040,
+	PRISM2_PARAM_RADAR_DETECT = 1043,
+	PRISM2_PARAM_SPECTRUM_MGMT = 1044,
+	/* NOTE: Please try to coordinate with other active development
+	 * branches before allocating new param numbers so that each new param
+	 * will be unique within all branches and the allocated number will not
+	 * need to be changed when merging new features. Existing numbers in
+	 * the mainline (or main devel branch) must not be changed when merging
+	 * in new features. */
+};
+
+/* PRISM2_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	PRISM2_HOSTAPD_FLUSH = 1,
+	PRISM2_HOSTAPD_ADD_STA = 2,
+	PRISM2_HOSTAPD_REMOVE_STA = 3,
+	PRISM2_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	PRISM2_SET_ENCRYPTION = 6,
+	PRISM2_GET_ENCRYPTION = 7,
+	PRISM2_HOSTAPD_SET_FLAGS_STA = 8,
+	PRISM2_HOSTAPD_GET_RID = 9,
+	PRISM2_HOSTAPD_SET_RID = 10,
+	PRISM2_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	PRISM2_HOSTAPD_MLME = 13,
+
+	/* Instant802 additions */
+	PRISM2_HOSTAPD_SET_BEACON = 1001,
+        PRISM2_HOSTAPD_GET_HW_FEATURES = 1002,
+        PRISM2_HOSTAPD_SCAN = 1003,
+	PRISM2_HOSTAPD_WPA_TRIGGER = 1004,
+	PRISM2_HOSTAPD_SET_RATE_SETS = 1005,
+        PRISM2_HOSTAPD_ADD_IF = 1006,
+        PRISM2_HOSTAPD_REMOVE_IF = 1007,
+        PRISM2_HOSTAPD_GET_DOT11COUNTERSTABLE = 1008,
+        PRISM2_HOSTAPD_GET_LOAD_STATS = 1009,
+        PRISM2_HOSTAPD_SET_STA_VLAN = 1010,
+	PRISM2_HOSTAPD_SET_GENERIC_INFO_ELEM = 1011,
+	PRISM2_HOSTAPD_SET_CHANNEL_FLAG = 1012,
+	PRISM2_HOSTAPD_SET_REGULATORY_DOMAIN = 1013,
+	PRISM2_HOSTAPD_SET_TX_QUEUE_PARAMS = 1014,
+	PRISM2_HOSTAPD_SET_BSS = 1015,
+	PRISM2_HOSTAPD_GET_TX_STATS = 1016,
+	PRISM2_HOSTAPD_UPDATE_IF = 1017,
+	PRISM2_HOSTAPD_SCAN_REQ = 1019,
+	PRISM2_STA_GET_STATE = 1020,
+	PRISM2_HOSTAPD_FLUSH_IFS = 1021,
+	PRISM2_HOSTAPD_SET_RADAR_PARAMS = 1023,
+	PRISM2_HOSTAPD_SET_QUIET_PARAMS = 1024,
+	PRISM2_HOSTAPD_GET_TX_POWER = 1025,
+	/* NOTE: Please try to coordinate with other active development
+	 * branches before allocating new param numbers so that each new param
+	 * will be unique within all branches and the allocated number will not
+	 * need to be changed when merging new features. Existing numbers in
+	 * the mainline (or main devel branch) must not be changed when merging
+	 * in new features. */
+};
+
+	/* these definitions mirror the ieee80211_i.h
+	 * IEEE80211_DISABLED, ... IEEE80211_ASSOCIATED enumeration */
+enum {
+	PRISM2_PARAM_STA_DISABLED,
+	PRISM2_PARAM_STA_AUTHENTICATE,
+	PRISM2_PARAM_STA_ASSOCIATE,
+	PRISM2_PARAM_STA_ASSOCIATED,
+};
+
+#define PRISM2_HOSTAPD_MAX_BUF_SIZE 2048
+#define HOSTAP_CRYPT_ALG_NAME_LEN 16
+
+/* Use this to make sure that structure elements are correctly aligned
+ * for access as other types. Most commonly, this affects the placeholder
+ * types used for data at the end of a structure in this union.
+ */
+#ifdef __GNUC__
+#undef	ALIGNED
+#define ALIGNED __attribute__ ((aligned))
+#else
+/* Check if it has been defined elsewhere */
+#ifndef ALIGNED
+#error "Must define ALIGNED to generate aligned structure elements"
+#endif
+#endif
+
+struct prism2_hostapd_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	u8 pad[2];
+	union {
+		struct {
+			u16 aid;
+			u16 capability;
+			u8 supp_rates[32];
+			/* atheros_super_ag and enc_flags are only used with
+			 * IEEE80211_ATHEROS_SUPER_AG 
+			 */
+			u8 atheros_super_ag;
+			u8 atheros_xr_mode;
+			u8 wds_flags;
+#define IEEE80211_STA_DYNAMIC_ENC BIT(0)
+			u8 enc_flags;
+		} add_sta;
+		struct {
+			u32 inactive_msec;
+			u32 rx_packets;
+			u32 tx_packets;
+			u32 rx_bytes;
+			u32 tx_bytes;
+			u32 current_tx_rate; /* in 100 kbps */
+                        u32 channel_use;
+                        u32 flags;
+			u32 num_ps_buf_frames;
+			u32 tx_retry_failed;
+			u32 tx_retry_count;
+			u32 last_rssi;
+			u32 last_ack_rssi;
+		} get_info_sta;
+		struct {
+			u8 alg[HOSTAP_CRYPT_ALG_NAME_LEN];
+			u32 flags;
+			u32 err;
+			u8 idx;
+#define HOSTAP_SEQ_COUNTER_SIZE 8
+			u8 seq_counter[HOSTAP_SEQ_COUNTER_SIZE];
+			u16 key_len;
+			u8 key[0] ALIGNED;
+		} crypt;
+		struct {
+			u32 flags_and;
+			u32 flags_or;
+		} set_flags_sta;
+		struct {
+			u16 rid;
+			u16 len;
+			u8 data[0] ALIGNED;
+		} rid;
+		struct {
+			u16 head_len;
+			u16 tail_len;
+			u8 data[0] ALIGNED; /* head_len + tail_len bytes */
+		} beacon;
+		struct {
+			u16 num_modes;
+			u16 flags;
+			u8 data[0] ALIGNED; /* num_modes * feature data */
+                } hw_features;
+                struct {
+                        u8  now;
+                        s8  our_mode_only;
+                        s16 last_rx;
+                        u16 channel;
+                        s16 interval; /* seconds */
+                        s32 listen;   /* microseconds */
+                } scan;
+		struct {
+#define WPA_TRIGGER_FAIL_TX_MIC BIT(0)
+#define WPA_TRIGGER_FAIL_TX_ICV BIT(1)
+#define WPA_TRIGGER_FAIL_RX_MIC BIT(2)
+#define WPA_TRIGGER_FAIL_RX_ICV BIT(3)
+#define WPA_TRIGGER_TX_REPLAY BIT(4)
+#define WPA_TRIGGER_TX_REPLAY_FRAG BIT(5)
+#define WPA_TRIGGER_TX_SKIP_SEQ BIT(6)
+			u32 trigger;
+		} wpa_trigger;
+		struct {
+			u16 mode; /* MODE_* */
+			u16 num_supported_rates;
+			u16 num_basic_rates;
+			u8 data[0] ALIGNED; /* num_supported_rates * u16 +
+				             * num_basic_rates * u16 */
+                } set_rate_sets;
+                struct {
+			u8 type; /* WDS, VLAN, etc */
+			u8 name[IFNAMSIZ];
+                        u8 data[0] ALIGNED;
+                } if_info;
+                struct dot11_counters {
+                        u32 dot11TransmittedFragmentCount;
+                        u32 dot11MulticastTransmittedFrameCount;
+                        u32 dot11FailedCount;
+                        u32 dot11ReceivedFragmentCount;
+                        u32 dot11MulticastReceivedFrameCount;
+                        u32 dot11FCSErrorCount;
+                        u32 dot11TransmittedFrameCount;
+                        u32 dot11WEPUndecryptableCount;
+			u32 dot11ACKFailureCount;
+			u32 dot11RTSFailureCount;
+			u32 dot11RTSSuccessCount;
+                } dot11CountersTable;
+		struct {
+#define LOAD_STATS_CLEAR BIT(1)
+			u32 flags;
+			u32 channel_use;
+                } get_load_stats;
+                struct {
+                        char vlan_name[IFNAMSIZ];
+			int vlan_id;
+                } set_sta_vlan;
+		struct {
+			u8 len;
+			u8 data[0] ALIGNED;
+		} set_generic_info_elem;
+		struct {
+			u16 mode; /* MODE_* */
+			u16 chan;
+			u32 flag;
+                        u8  power_level; /* regulatory limit in dBm */
+                        u8  antenna_max;
+		} set_channel_flag;
+                struct {
+                        u32 rd;
+                } set_regulatory_domain;
+		struct {
+			u32 queue;
+			s32 aifs;
+			u32 cw_min;
+			u32 cw_max;
+			u32 burst_time; /* maximum burst time in 0.1 ms, i.e.,
+					 * 10 = 1 ms */
+		} tx_queue_params;
+		struct {
+			u32 bss_count;
+			u8 bssid_mask[ETH_ALEN];
+		} set_bss;
+		struct ieee80211_tx_stats {
+			struct {
+				unsigned int len; /* num packets in queue */
+				unsigned int limit; /* queue len (soft) limit
+						     */
+				unsigned int count; /* total num frames sent */
+			} data[4];
+		} get_tx_stats;
+		struct {
+			u8 ssid_len;
+			u8 ssid[0] ALIGNED;
+		} scan_req;
+		struct {
+			u32 state;
+		} sta_get_state;
+		struct {
+#define MLME_STA_DEAUTH 0
+#define MLME_STA_DISASSOC 1
+			u16 cmd;
+			u16 reason_code;
+		} mlme;
+		struct {
+			unsigned int value;
+		/* 	TODO
+			int pulse_width;
+			int num_pulse;
+			int period;
+		*/
+		}radar;
+		struct {
+			unsigned int period;
+			unsigned int offset;
+			unsigned int duration;
+		}quiet;
+		struct {
+			unsigned int tx_power_min;
+			unsigned int tx_power_max;
+		}tx_power;
+		struct {
+			u8 dummy[80]; /* Make sizeof() this struct large enough
+				       * with some compiler versions. */
+		} dummy;
+	} u;
+};
+
+
+#ifndef IEEE80211_TX_QUEUE_NUMS
+#define IEEE80211_TX_QUEUE_NUMS
+/* TODO: these need to be synchronized with ieee80211.h; make a shared header
+ * file that can be included into low-level drivers, 80211.o, and hostapd */
+/* tx_queue_params - queue */
+enum {
+	IEEE80211_TX_QUEUE_DATA0 = 0, /* used for EDCA AC_VO data */
+	IEEE80211_TX_QUEUE_DATA1 = 1, /* used for EDCA AC_VI data */
+	IEEE80211_TX_QUEUE_DATA2 = 2, /* used for EDCA AC_BE data */
+	IEEE80211_TX_QUEUE_DATA3 = 3, /* used for EDCA AC_BK data */
+	IEEE80211_TX_QUEUE_DATA4 = 4,
+	IEEE80211_TX_QUEUE_AFTER_BEACON = 6,
+	IEEE80211_TX_QUEUE_BEACON = 7
+};
+#endif /* IEEE80211_TX_QUEUE_NUMS */
+
+
+#define HOSTAP_CRYPT_FLAG_SET_TX_KEY BIT(0)
+#define HOSTAP_CRYPT_FLAG_PERMANENT BIT(1)
+
+#define HOSTAP_CRYPT_ERR_UNKNOWN_ALG 2
+#define HOSTAP_CRYPT_ERR_UNKNOWN_ADDR 3
+#define HOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED 4
+#define HOSTAP_CRYPT_ERR_KEY_SET_FAILED 5
+#define HOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED 6
+#define HOSTAP_CRYPT_ERR_CARD_CONF_FAILED 7
+
+#define HOSTAP_HW_FLAG_NULLFUNC_OK BIT(0)
+
+enum {
+	IEEE80211_KEY_MGMT_NONE = 0,
+	IEEE80211_KEY_MGMT_IEEE8021X = 1,
+	IEEE80211_KEY_MGMT_WPA_PSK = 2,
+	IEEE80211_KEY_MGMT_WPA_EAP = 3,
+};
+
+
+/* Data structures used for get_hw_features ioctl */
+struct hostapd_ioctl_hw_modes_hdr {
+	int mode;
+	int num_channels;
+	int num_rates;
+};
+
+struct ieee80211_channel_data {
+	short chan; /* channel number (IEEE 802.11) */
+	short freq; /* frequency in MHz */
+	int flag; /* flag for hostapd use (IEEE80211_CHAN_*) */
+};
+
+struct ieee80211_rate_data {
+	int rate; /* rate in 100 kbps */
+	int flags; /* IEEE80211_RATE_ flags */
+};
+
+
+/* ADD_IF, REMOVE_IF, and UPDATE_IF 'type' argument */
+enum {
+	HOSTAP_IF_WDS = 1, HOSTAP_IF_VLAN = 2, HOSTAP_IF_BSS = 3,
+	HOSTAP_IF_STA = 4
+};
+
+struct hostapd_if_wds {
+        u8 remote_addr[ETH_ALEN];
+};
+
+struct hostapd_if_vlan {
+        u8 id;
+};
+
+struct hostapd_if_bss {
+        u8 bssid[ETH_ALEN];
+};
+
+struct hostapd_if_sta {
+};
+
+#define PRISM2_DSCAPE_GENERIC_ELEMENT_HDR_LEN \
+((int) (&((struct prism2_hostapd_param *) 0)->u.set_generic_info_elem.data))
+
+#endif /* DSCAPE_HOSTAPD_IOCTL_H */
diff -upN wpa_supplicant-0.4.7/src/drivers/drivers.c wpa_supplicant-0.4.7-dev/src/drivers/drivers.c
--- wpa_supplicant-0.4.7/src/drivers/drivers.c	2005-02-20 01:15:54.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/src/drivers/drivers.c	2005-12-18 12:13:21.000000000 +0100
@@ -18,6 +18,9 @@
 #ifdef CONFIG_DRIVER_HOSTAP
 extern struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
 #endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_DSCAPE
+extern struct wpa_driver_ops wpa_driver_dscape_ops; /* driver_dscape.c */
+#endif /* CONFIG_DRIVER_DSCAPE */
 #ifdef CONFIG_DRIVER_PRISM54
 extern struct wpa_driver_ops wpa_driver_prism54_ops; /* driver_prism54.c */
 #endif /* CONFIG_DRIVER_PRISM54 */
@@ -62,6 +65,9 @@ struct wpa_driver_ops *wpa_supplicant_dr
 #ifdef CONFIG_DRIVER_HOSTAP
 	&wpa_driver_hostap_ops,
 #endif /* CONFIG_DRIVER_HOSTAP */
+#ifdef CONFIG_DRIVER_DSCAPE
+        &wpa_driver_dscape_ops,
+#endif /* CONFIG_DRIVER_DSCAPE */
 #ifdef CONFIG_DRIVER_PRISM54
 	&wpa_driver_prism54_ops,
 #endif /* CONFIG_DRIVER_PRISM54 */
diff -upN wpa_supplicant-0.4.7/src/drivers/ieee80211_shared.h wpa_supplicant-0.4.7-dev/src/drivers/ieee80211_shared.h
--- wpa_supplicant-0.4.7/src/drivers/ieee80211_shared.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/src/drivers/ieee80211_shared.h	2005-12-18 12:13:21.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * IEEE 802.11 -- shared defines for low-level drivers, 80211.o, and hostapd
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_SHARED_H
+#define IEEE80211_SHARED_H
+
+/* 802.11g is backwards-compatible with 802.11b, so a wlan card can
+ * actually be both in 11b and 11g modes at the same time. */
+enum {
+	MODE_IEEE80211A = 0 /* IEEE 802.11a */,
+	MODE_IEEE80211B = 1 /* IEEE 802.11b only */,
+	MODE_ATHEROS_TURBO = 2 /* Atheros Turbo mode (2x.11a at 5 GHz) */,
+	MODE_IEEE80211G = 3 /* IEEE 802.11g (and 802.11b compatibility) */,
+	MODE_ATHEROS_TURBOG = 4 /* Atheros Turbo mode (2x.11g at 2.4 GHz) */,
+	MODE_ATHEROS_PRIME = 5 /* Atheros Dynamic Turbo mode */,
+	MODE_ATHEROS_PRIMEG = 6 /* Atheros Dynamic Turbo mode G */,
+	MODE_ATHEROS_XR = 7 /* Atheros XR mode  */,
+	NUM_IEEE80211_MODES = 8
+};
+
+#define IEEE80211_CHAN_W_SCAN 0x00000001
+#define IEEE80211_CHAN_W_ACTIVE_SCAN 0x00000002
+#define IEEE80211_CHAN_W_IBSS 0x00000004
+
+/* Low-level driver should set PREAMBLE2, OFDM, CCK, and TURBO flags.
+ * BASIC, SUPPORTED, ERP, and MANDATORY flags are set in 80211.o based on the
+ * configuration. */
+#define IEEE80211_RATE_ERP 0x00000001
+#define IEEE80211_RATE_BASIC 0x00000002
+#define IEEE80211_RATE_PREAMBLE2 0x00000004
+#define IEEE80211_RATE_SUPPORTED 0x00000010
+#define IEEE80211_RATE_OFDM 0x00000020
+#define IEEE80211_RATE_CCK 0x00000040
+#define IEEE80211_RATE_TURBO 0x00000080
+#define IEEE80211_RATE_MANDATORY 0x00000100
+#define IEEE80211_RATE_XR 0x00000200
+
+#define IEEE80211_RATE_CCK_2 (IEEE80211_RATE_CCK | IEEE80211_RATE_PREAMBLE2)
+#define IEEE80211_RATE_MODULATION(f) \
+(f & (IEEE80211_RATE_CCK | IEEE80211_RATE_OFDM))
+
+
+#endif /* IEEE80211_SHARED_H */
diff -upN wpa_supplicant-0.4.7/wpa_supplicant/Makefile wpa_supplicant-0.4.7-dev/wpa_supplicant/Makefile
--- wpa_supplicant-0.4.7/wpa_supplicant/Makefile	2005-11-21 02:42:12.000000000 +0100
+++ wpa_supplicant-0.4.7-dev/wpa_supplicant/Makefile	2005-12-18 12:13:21.000000000 +0100
@@ -61,6 +61,13 @@ OBJS_d += driver_hostap.o
 CONFIG_WIRELESS_EXTENSION=y
 endif
 
+ifdef CONFIG_DRIVER_DSCAPE
+CFLAGS += -DCONFIG_DRIVER_DSCAPE
+OBJS_d += ../src/drivers/driver_dscape.o
+CONFIG_WIRELESS_EXTENSION=y
+endif
+
+
 ifdef CONFIG_DRIVER_WEXT
 CFLAGS += -DCONFIG_DRIVER_WEXT
 CONFIG_WIRELESS_EXTENSION=y
